package io.github.twalgor.main;

import java.io.File;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;

import io.github.twalgor.acsd.ACSDecomposition;
import io.github.twalgor.common.Chordal;
import io.github.twalgor.common.Graph;
import io.github.twalgor.common.Minor;
import io.github.twalgor.common.TreeDecomposition;
import io.github.twalgor.common.XBitSet;
import io.github.twalgor.lower.FillAndBreak;
import io.github.twalgor.lower.LBThread;
import io.github.twalgor.upper.HBTMerge;
import io.github.twalgor.upper.LocalUBNew;


public class UpLow {
  static final int VERSION = 1;
  
  private static void solve(String graphPath, String tdPath, String certPath) {
    Calendar cl = Calendar.getInstance();
    Date date = new Date();
    
    date = cl.getTime();
    System.out.println(date);
    
    File graphFile = new File(graphPath);
    String name = graphFile.getName();
    int pos = name.indexOf(".gr");
    assert pos >= 0;
    name = name.substring(0, pos);

    Graph g = Graph.readGraph(new File(graphPath));

    ResultFile certFile = new ResultFile(certPath);
    certFile.addLine("title lowerbound certificates generated by FillAndBreak in the heuristic exact treewidth computation");
    certFile.addLine("param UNC_CHUNK " + FillAndBreak.UNC_CHUNK);
    certFile.addLine("param N_TRY " + FillAndBreak.N_TRY);
    certFile.addLine("graph_file " + graphPath);
    certFile.addLine("graph_size n " + g.n + " m " + g.numberOfEdges());
    
    ACSDecomposition acsd = new ACSDecomposition(g);
    acsd.decomposeByACS();
    
    XBitSet[] aa = new XBitSet[acsd.acAtoms.size()];
    acsd.acAtoms.toArray(aa);
    Arrays.sort(aa, (a1, a2) -> -XBitSet.cardinalityComparator.compare(a1, a2));
    
    LocalUBNew[] localUB = new LocalUBNew[aa.length];
    Shared shared = new Shared(g.n - 1, 1, System.currentTimeMillis());
    for (int i = 0; i < aa.length; i++) {
      localUB[i] = new LocalUBNew(g, aa[i], shared);
      localUB[i].initialUB();
    }
    int iMax = maxUBIndex(localUB);

    int ub = localUB[iMax].getUB();
    
    Graph tr = g.copy();
    for (LocalUBNew lub: localUB) {
      lub.fillTriangulation(tr);
    }
    
    TreeDecomposition td = Chordal.chordalToTD(tr);
    td.g = g;
    long t = System.currentTimeMillis();
    assert td.width == ub;
    ResultFile tdFile = new ResultFile(tdPath);
    tdFile.addLine("c tree-decompostition computed by HBTMerge");
    tdFile.addLine("c N_INITIAL_GREEDY " + HBTMerge.N_INITIAL_GREEDY + 
        " BASE_SIZE " + HBTMerge.BASE_SIZE + 
        " N_TRY " + HBTMerge.N_TRY);
    tdFile.addLine("c graph_path " + graphPath);
    tdFile.addLine("c n " + g.n + " width " + ub + " time " + (t - shared.getT0()));
    tdFile.addLine("s td " + td.nb + " " + (td.width + 1) + " " + g.n);
    for (int b = 1; b <= td.nb; b++) {
      tdFile.addLine("b " + b + vaToString(td.bags[b]));
    }
    for (int b = 1; b <= td.nb; b++) {
      for (int b1: td.neighbor[b]) {
        if (b1 > b) {
          tdFile.addLine(b + " " + b1);
        }
      }
    }
    tdFile.close();

    shared.setUB(ub);
    
    certFile.addLine("largest_atom " + aa[0].cardinality());

    certFile.addLine("local_graph n " + localUB[0].getGraph().n + " m " + 
        localUB[0].getGraph().numberOfEdges());
    
    Minor baseMinor = acsd.minorForAtom(aa[0]);
    
    LBThread lbThread = new LBThread(baseMinor, shared, certFile);
    lbThread.start();
    
    while (shared.getLB() < shared.getUB()) {
      System.out.println(shared.getLB() + ":" + shared.getUB() + ", " + ub);
      iMax = maxUBIndex(localUB);
      int oldUB = localUB[iMax].getUB();
      localUB[iMax].improveUB();
      if (localUB[iMax].getUB() < oldUB) {
        t = System.currentTimeMillis();
        System.out.println("improved at " + iMax + ": " + localUB[iMax].getUB() + 
            ", " + (t - shared.getT0()) + " millisecs");
      }
      iMax = maxUBIndex(localUB);
      if (localUB[iMax].getUB() < ub) {
        ub = localUB[iMax].getUB();
        shared.setUB(ub);
        tr = g.copy();
        for (LocalUBNew lub: localUB) {
          lub.fillTriangulation(tr);
        }
        
        td = Chordal.chordalToTD(tr);
        td.g = g;
        t = System.currentTimeMillis();
        assert td.width == ub;
        tdFile = new ResultFile(tdPath);
        tdFile.addLine("c graph_path " + graphPath);
        tdFile.addLine("c n " + g.n + " width " + ub + " time " + (t - shared.getT0()));
        tdFile.addLine("s td " + td.nb + " " + (td.width + 1) + " " + g.n);
        for (int b = 1; b <= td.nb; b++) {
          tdFile.addLine("b " + b + vaToString(td.bags[b]));
        }
        for (int b = 1; b <= td.nb; b++) {
          for (int b1: td.neighbor[b]) {
            if (b1 > b) {
              tdFile.addLine(b + " " + b1);
            }
          }
        }
        tdFile.close();
      }
    }
    shared.setStop(true);
  }

  static String vaToString(int[] va) {
    StringBuilder sb = new StringBuilder();
    for (int v: va) {
      sb.append(" " + (v + 1));
    }
    return sb.toString();
  }
  
  static String baToString(int b, int[] ba) {
    StringBuilder sb = new StringBuilder();
    return sb.toString();
  }
  
  static int maxUBIndex(LocalUBNew[] localUB) {
    int iMax = 0;
    for (int i = 1; i < localUB.length; i++) {
      if (localUB[i].getUB() > localUB[iMax].getUB()) {
        iMax = i;
      }
    }
    return iMax;
  }
  
  public static void main(String[] args) {
    if (args.length == 0) {
//      String name = "Promedas_68_13";
//      String name = "Promedas_28_10";
//      String name = "Promedas_11_7";
//      String name = "Promedas_27_8";
//      String name = "Pedigree_11_6";
//      String name = "Pedigree_12_12";
      String name = "Promedus_18_10";
      args = new String[] {
          "..\\instance\\PACE2017bonus_gr\\" + name + ".gr", 
          "c:\\Users\\Hisao\\Dropbox\\td\\PACE2017bonus_gr\\" + name + ".td",
          "c:\\Users\\Hisao\\Dropbox\\certificate1\\PACE2017bonus_gr\\" + name + ".mnr"
      };
    }
    assert args.length >= 3;
    solve(args[0], args[1], args[2]);
  }
}
